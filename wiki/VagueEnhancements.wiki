#summary Enhancement directions very likely to see work, but no specifics.

= Introduction =

I have a list of specific enhancements I included on the front page, which I'll migrate back here eventually.  But I was thinking about how I look at other projects and wonder where they are headed.  Often, other project owners resist discussing the future because they don't want to get anyone's hopes up, or they've really stopped using or improving the product, but they don't want to give up ownership, so they can't say much at all about the future.

I use lister every day all day to get my work done, so I can clearly see what I need in the future to enhance my work.  I might discover that an enhancement is too much work for too little gain, and defund it, but otherwise they are for real likely directions.


= Details =


  * I need to manage my BRDs and DRFs and ETL specs and yada yada.  Tools I access are *SharePoint* and *Discovery*.  
  * I prefer SharePoint but it has many bugs when paths exceed 256 characters and checkouts rapidly get corrupted and destroyed.
  * Updating SharePoint pages with notes on BA status and test status, progress, etc would be great.  Latency is a big issue for me.  I need tools that can batch update, download, search, etc.
  * Checking in/out/uploading to any doc server with high latency means I want it to run in the background and tell me when its done, and recover when (not if) it crashes.
  * Discovery is hard to work with and paths are numbers and not meaningful strings, so management is critical to understand which is what.
  * *Microsoft Project* is used to track deliverables and it is expected we use it daily, but it is slow, and changes are confusing and not tracked.  A deliverable may start as due Tuesday, then be changed magically to Friday.  If not tracked, the history is lost and you can't point out at the Quarterly meeting that Project deliverable estimates were initially off from final dates by 300% for 20 projects, etc.  The tools suck, the managers are idiots, so I have to make my own metrics.

  * QCs are tickets that track micro-change and requests and status, and the tool, *Mercury QualityCenter* is anything BUT mercurial.  It crashes, times out quickly, bogs down, and even loses changes.  But the company loves it, so we are stuck with it.
  * It supports a VB/OLE API of sorts so I need to hack that together and store tickets externally, so I can quickly review them and not deal with a crappy interface just to read a problem description that has not changed in years.  Plus the attributes used are already claimed by the QA team, without bothering to document or let us know which ones or what.  I need to document all the values expected for each attribute, just like any other database.  Plus workflow.  What status should move to what when and during what cycle?  We should be able to historically say "On Friday the 10th of May, this ticket was "Ready for Testing", but the Users were not ready for UAT, the QA team had no resources for QA, the database QA environment was locked down for UAT for project Y, so data from the source R's UAT environment could not be imported, and they had to flush their UAT environment in +8 days for our overriding commitment to bring in procurement L in +10 days"

    See how bizarre it can get?  Use cases are required to see what can be done.
Here are some of the objects I see:

      * Document: in a stage and versioned, release stage, _this version_ reviewed by
      * State: Each tool and team has the same name for a cycle or state, but different meaning and different flow from state to state, and different flow _back_ from states, plus hidden states, secret states, begrudged states, "lie" states...
      * Sources: Where'd it come from
      * Project: Business view
      * Procurements: A project, but a source is always involved, the "Database" is always targeted, a user is involved, cycle involved, and a real Client project overrides it, in fact, multiple clients are linked to procurements, and want different attributes and cycles and stakeholding levels.
      * Environment: Names are confused with "Cycles".  They are really just names for what I call instances.  But the names create political and legal requirements, like the SEC may require that all Production environments have certain access protocols, even specific vendors(!).  Shareholders view problems in certain environments as more serious.  So "what the fucks in a name" has serious implications.  Note  that people have shorthands for the same physical instance, which creates problems, too.  Joe may call it UAT, Steve calls it Pre-prod, Mary calls it QA or SIT.  And if you can find a corporation where you can refer to 3 people in the same sentence as Joe, Steve, and Mary, sign me up!
      * Tickets:  Tickets, like everything, take on a life of their own, meaning they may have been creating to be helpful tracking tools, only to become tools for the user to beat you over the head with.  They often are just variations on a theme, but QC doesn't really support that!  Also, cycling tasks, like "Load source into UAT for 5/10 through 5/20.  Don't miss a day!!" becomes a non-closing ticket, which makes ticket metrics way off.  Average closure time becomes meaningless.  Longest open ticket: Meaninglessssss!  But does QC care? no.
        Tickets also get CLOSED as in, pretty much done, and no one is going to work on them, but they have to stay open because they are _technically_ not done.  For instance, find .001% difference between two target environments that can't be understood, but we go forward anyway.  There needs to be separate statuses!  A status for "Cycle complete" needs to be different than the technical state flow of "Open"-"Closed".  Get it, people???  Seems simple, but they don't get it.  There needs to be a "Showstopper" flag, and which cycle its a show stopper for.  For instance, an incorrect data value could be a showstopper for UAT, QA, or Production release, or stable production.

        Here's a thought: What about the fact that production is really many cycles?  There's the "baby" release when it goes out all pristine and broken and buggy, we all know its before the user needs it, because the Legal Day One is weeks further, but we can't allow ourselves to differentiate, or else we are admitting that Production release A is not perfect.  But it really is Alpha!  The stages in production should be named: Alpha, Beta, Release Candidate, Approved for Legal use, Stable, Mature, Sunsetted.  What about features no longer used?  Should be documented so they can be altered for new requirements.

        User connectivity and interaction with the database needs to be tracked.  Views should be INSTEAD OF views or Stored proc APIs that log usage, and have some requirements that periodically force user involvement, even coincidentally.  These can be fabricated, like "Every year the user has to enter a new code or the partition breaks", I don't know.  Some way to force users to stay involved, so that when they are not (inevitably), the project can be more easily sunsetted.  Even build it into the signoff.  The signoff should go both ways.  "I commit to a data review, which, if I or my agent does not complete, means the project will enter sunset initialization" probably for some planned time.  There should be planned "random" outages or delays every year, just to see if anyone's out there.

        * Timelines:  Timelines should update daily to keep the data easy to navigate.  They would link different values all to a specific time interval.  Status of source X for deliverable Y was G, target database L was 30%, all dated MM/DD/YY.  This would make metrics easier.  Save the data in meaningful format _before_ you think of the use, otherwise there's no history when you _do_ need the metric.

        * Deliverables:  Attached to projects, cycles, tickets, dates, etc.

        * Dates: Dates should be concrete, discrete things, because that's how people talk about them.  "Did we meet The Date?", "The Date slipped."  Then you attach to a Timeline, and track it thusly, and watch it slip away :)

        * Scope:  This a fun thing, and should be defined in user terms, not in any way linked to real code function!  No, just list the scope in Dimensions that are standardized and watch them creep up and change definition.  "When I said 'just NY' I meant all global data that 'passed through' NY, everybody knows that!".

        * Signoffs:  These are dumb.  Just stupid.  But tracking them is not dumb.  Managers come down with these ultimatums that you get a signoff from the user.  The manager, dev team, ba team, and user dev team, user bas, user, user manager, user manager's manager, all these cannot in any reality possibly agree on what _SIGN-OFF_ means.  They all come from different backgrounds.  If we were all experts at what each other does, why would we need the others?  So sign-offs are mandatory, and BAs should just try to ease them through.  If they can be forgotten, great!  If the managers forget, great!  But sometimes thats all they have on _their_ task list is "Get signoff from business".  FYI, no one ever goes back to a signoff and holds it over a user's head.  Think back.  Can you remember such a time.  Unless its a legal contract between parties external to each other, it doesn't matter.  Unless of course law suits come up, or SEC OCC gets involved, I suppose you'll pull that out then.  Scary stuff, but who lives like that?  Naw, just get the signoff.  We need scripts to ploy the user into sending a vague email, verbally clarifying how meaningless it is.

        Now the user often can use the signoff requirement to beat a team into high priority work, which is probably not what the dev-side management intended.  It's a bit laughable when you see the unintended consequences.  The signoff actually gives more power to user when it was intended to grant safety to the provider.

        Provider/Consumer.  How 'bout we use these terms to clarify the sides?  It probably describes all parties internal to a company.  There are BAs and managers Provider and Consumer Side.  We'll call it Side in the Control database.  On the Provider side, there are Sources.

        Milestones.  Millstones?  These are usually tied to dates.  They have some sort of measurability to them, and are often skipped, forgotten.  For BAs they could help with proving to users and managers that you actually MET your deliverable or requirement.  It is very hard to close a Ticket if you can't list milestones met.

        Approvals.  Sounds like Signoffs in a third-normal-form sense.  This is the problem with developers designing tracking systems!  They can't think like a user!  They are *ALWAYS* trying to find the common shared data and so "save" and simplify a system.  HOWEVER, users are not systems!!! They can't be simplified.  Keep trying, though LOLOL.  Sad.  Not really funny.  Dev thinking vs. People think.  Who wins? Hopefully people-think.

        Anywoo, store approvals and always use them in lue of signoffs unless you can foresee a charge of willful blindness if you don't.  A user is much more likely to approve something than to signoff on something.

        "Agreements". Don't use this word because its to legalese.  But you need a way to track when cross-sides agree, especially at contact points.  If in a Meeting you and the opposing BA agree verbally, as in, "Yeah, that'll work." GRAB IT!  Probably should try to say, "So, do you agree this Ticket can be Closed?".  Be vague if you need to squeeze, maybe you mean close the technical side, maybe you really mean "Ready for Production".  Don't be too clear, or they get confused!  But log the agreement if they really did.  Just ask yourself, will they remember this?  People usually remember if they really thought for a minute and _agreed_ to something. If its just a rambling conversation and the user's BA just was "yeah, yeah", or "yeah, whatever", then your causing yourself and others grief to write that down.  Consumers send verbal queues that we need to be alert for and responsive to, not try to manipulate.  Only because it won't work.  If manipulation worked, then I'd be for it.  But the nature of a _Consumer_ is that they can seek consumption elsewhere or even cease consuming, which leaves you out of a job as a _Provider_.